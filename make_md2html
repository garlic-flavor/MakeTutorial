#!/usr/bin/env zsh
# hideShebang
## ## __試験実装__
##
## ## 概要
## MarkdownからHTMLを生成する。
##
## ## 動機
## - MacOSでMarkdownを開くデフォルトアプリをXCodeから変えられない。
## - とりあえずHTML生成に対応しておけば何かいいことがあるかも知れない。
##
## ## 目標
## - 単一でJavascriptを使用しないHTMLを生成する。
##
## ## 謝辞
## - [cmark-gfm](https://github.com/github/cmark-gfm)を使っています。
BACKEND=cmark-gfm

## ## 使い方
USAGE="MakeMD2HTML: MarkdownからHTMLを生成する。

使い方:
>$0 [-o out.html] [-b cmark-gfm] file
"

## ### HTMLヘッダ
## 色を変える場合はここの<style>要素内をいじる。
function writeHeader {
  echo "<!DOCTYPE html>
<html lang=\"ja\">
  <head>
    <title>test.html</title>
    <meta charset=\"utf-8\">
    <style>
      h1 {
        padding-left: 20px;
        background-color: lightgray;
      }
      code:not(pre code) {
        background-color: lightyellow;
        padding-left: 5px;
        padding-right: 5px;
      }
      pre:has(code) {
        border-style: solid;
        border-width: 1;
        border-color: gray;
        background-color: lightyellow;
        padding: 10px 10px 10px 10px;
      }
      .keyword {
        color: red;
      }
      .keyword2 {
        color: purple;
      }
      .comment {
        color: green;
      }
      .string {
        color: blue;
      }
      .variable {
        color: brown;
      }
      .output {
        padding-left: 5px;
        border-left: 5px solid darkslategray;
        color: darkslategray;
      }
    </style>
  </head>
  <body>"
}

## ### HTMLフッタ
function writeFooter {
  echo "
  </body>
</html>"
}

## ### 各言語で共用する部分
typeset -g rest # グローバル変数で使いまわしてるので注意
typeset -g quote # クォートの内部かどうか

## ### とりあえず一文字処理する。
function processChar {
  local n=$1
  if [[ -z $n ]]; then n=1; fi
  echo -E -n - ${rest:0:$n}
  rest=${rest:$n}
}

## ### 一行コメントを処理する。
function processComment {
  local header=$1 class=$2
  if [[ -z $header ]]; then header='#'; fi
  if [[ -z $class ]]; then class='comment'; fi
  if [[ $rest != $header* ]]; then return 1; fi
  echo -E -n "<span class=\"$class\">$rest</span>"
  rest=
}

## ### エスケープシーケンスを処理する。
function processEscapeSequence {
  if [[ $rest != "\\"* ]]; then return 1; fi
  processChar; processChar;
}

## ### 文字列を開始する。
function processQuoteOpen {
  local q=$1 class=$2
  if [[ -n $quote ]]; then return 1; fi
  if [[ -z $q ]]; then q="'"; fi
  if [[ -z $class ]]; then class="string"; fi
  if [[ $rest != $q* ]]; then return 1; fi
  quote=$q
  echo -E -n "<span class=\"$class\">"
  processChar
}

## ### 文字列を終了する。
function processQuoteClose {
  if [[ -z $quote ]]; then return 1; fi
  if [[ $rest != $quote* ]]; then return 1; fi
  processChar ${#quote}
  echo -E -n "</span>"
  quote=
}

## ### 一単語処理する。
function processWord {
  local r=$1
  if [[ -z $r ]]; then r="[a-zA-Z0-9_]"; fi
  if [[ $rest =~ "^$r+" ]]; then
    processChar ${#MATCH}
  else
    return 1;
  fi
}

## ### キーワードを処理する。
function processKeywords {
  local keys=$1 class=$2
  if [[ -z $class ]]; then class='keyword'; fi
  if [[ ! $rest =~ "^($keys)[[:>:]]" ]]; then return 1; fi
  echo -E -n "<span class=\"$class\">"
  processChar ${#MATCH}
  echo -E -n "</span>"
}

## ### $変数参照を処理する。
function processVariableReference {
  local class=$1 nest=0
  if [[ $rest != '$'* ]]; then return 1; fi
  if [[ -z $class ]]; then class='variable'; fi
  echo -E -n "<span class=\"$class\">"
  processChar;
  if [[ $rest == '{'* ]]; then
    ((nest++))
    while [[ -n $rest ]]; do
      processChar
      if   (( $nest == 0 )); then
        break
      elif [[ $rest == '}'* ]]; then
        ((nest--))
      elif [[ $rest == '{'* ]]; then
        ((nest++))
      fi
    done
  else
    processWord "[a-zA-Z0-9_:]" || processChar
  fi
  echo -E -n "</span>"
}

## ### 出力行を処理する。
function processOutput {
  local header=$1 class=$2
  if [[ -z $header ]]; then header='#&gt;'; fi
  if [[ -z $class ]]; then class='output'; fi
  if [[ $rest != $header* ]]; then return 1; fi
  echo -E -n "<span class=\"$class\">${rest:${#header}}</span>"
  rest=
}

## ### 個別の言語の処理

## ### Shell Script を処理する。
function processSh {
  local key1=(function if then elif else fi local while do done for in)
  local key2=(echo print printf return exit)
  rest=$1
  while [[ -n $rest ]]; do
    if [[ -n $quote ]]; then
      processEscapeSequence || processQuoteClose || processChar
    else
      processVariableReference || \
      processOutput || processComment || \
      processQuoteOpen '&quot;' || processQuoteOpen "'" || \
      processQuoteOpen "\`" || \
      processKeywords ${(j<|>)key1} || \
      processKeywords ${(j<|>)key2} 'keyword2' || \
      processWord || \
      processChar
    fi
  done
}

## ### C/C++ を処理する。
function processC {
  local key1=(const for return if else while static switch case using \
    namespace constexpr noexcept enum class struct)
  local key2=(int void double size_t unsigned auto byte short )
  rest=$1
  while [[ -n $rest ]]; do
    if [[ -n $quote ]]; then
      processEscapeSequence || processQuoteClose || processChar
    else
      processOutput '//&gt;' || processComment || processComment '//' || \
      processQuoteOpen '&quot;' || processQuoteOpen "'" || \
      processKeywords ${(j<|>)key1} || \
      processKeywords ${(j<|>)key2} 'keyword2' || \
      processWord || \
      processChar
    fi
  done
}

## ### Tcl を処理する。
function processTcl {
  local key1=(proc if then elseif else for set switch default while upvar \
    global)
  local key2=(puts return incr array)
  rest=$1
  while [[ -n $rest ]]; do
    if [[ -n $quote ]]; then
      processEscapeSequence || processQuoteClose || processChar
    else
      processVariableReference || \
      processOutput || processComment || \
      processQuoteOpen '&quot;' || processQuoteOpen "'" || \
      processQuoteOpen "\`" || \
      processKeywords ${(j<|>)key1} || \
      processKeywords ${(j<|>)key2} 'keyword2' || \
      processWord || \
      processChar
    fi
  done
}

## ## HTML Body
## cmark-gfmの出力がここに来る。
function processBody {
  local language= rest pre tag post
  # タグ以外の平文を処理する。
  function processNonTag {
    if [[ -z $1 ]]; then return; fi
    # sh だった
    if   [[ $language == language-sh ]]; then
      processSh $1
    elif [[ $language == language-c || $language == language-cpp ]]; then
      processC $1
    elif [[ $language == language-tcl ]]; then
      processTcl $1
    else
      echo -E -n $1
    fi
  }
  # タグを処理する。
  function processTag {
    if [[ -z $1 ]]; then return; fi
    echo -E -n $1
    # code要素が来たらclass属性をlanguageに格納する。
    if [[ $1 =~ "^<code[[:space:]]+class[[:space:]]*=[[:space:]]*\"([^\"]*)\"[[:space:]]*>$" ]]; then
      language=$match[1]
    # /codeタグが来たらlanguageを終わる。
    elif [[ $1 =~ "^</code[[:space:]]*>$" ]]; then
      language=
    fi
  }

  while IFS='' read -r line; do
    rest=$line
    while [[ -n $rest ]]; do
      # タグとそれ以外に分離する。
      if [[ ! $rest =~ "^([^<]*)(<[^>]+>)?(.*)" ]]; then continue; fi
      pre=$match[1]; tag=$match[2]; post=$match[3]
      processNonTag $pre
      processTag $tag
      rest=$post
    done
    echo
  done
}

## ### オプションのパース
# 出力先 1 は標準出力
output=1
# オプションをパースする。
while getopts o:b:h OPT; do
  case $OPT in
    o) output=$OPTARG;;
    b) BACKEND=$OPTARG;;
    h) print $USAGE; exit;;
    *) print $USAGE; exit 1;;
  esac
done
shift $((OPTIND - 1))

## ## 出力処理
{
  writeHeader
  # stdin がターミナル(= パイプに接続されていない)。
  if [ -t 0 ]; then
    # 引数がある場合
    if [[ $1 ]]; then
      ${=BACKEND} $1 | processBody
    else
      print $USAGE
      exit 1
    fi
  # stdin がパイプに接続されている。
  else
    # パイプを処理する。
    ${=BACKEND} | processBody
  fi
  writeFooter
} >&$output

